define void @mcl_fp_add$(bit)S(i$(bit)* %pz, i$(bit)* %px, i$(bit)* %py, i$(bit)* %pp) {
entry:
	%x = load i$(bit)* %px
	%y = load i$(bit)* %py
	%p = load i$(bit)* %pp
	%x1 = zext i$(bit) %x to i$(bit+unit)
	%y1 = zext i$(bit) %y to i$(bit+unit)
	%p1 = zext i$(bit) %p to i$(bit+unit)
	%t0 = add i$(bit+unit) %x1, %y1 ; x + y
	%t1 = sub i$(bit+unit) %t0, %p1 ; x + y - p
	%t2 = lshr i$(bit+unit) %t1, $(bit)
	%t3 = trunc i$(bit+unit) %t2 to i1
	%t4 = select i1 %t3, i$(bit+unit) %t0, i$(bit+unit) %t1
	%t5 = trunc i$(bit+unit) %t4 to i$(bit)
	store i$(bit) %t5, i$(bit)* %pz
	ret void
}

define internal { i$(bit), i$(unit) } @mcl_local_sbb$(bit)(i$(bit) %x, i$(bit) %y) {
	%x1 = zext i$(bit) %x to i$(bit+unit)
	%y1 = zext i$(bit) %y to i$(bit+unit)
	%v1 = sub i$(bit+unit) %x1, %y1
	%v = trunc i$(bit+unit) %v1 to i$(bit)
	%c = lshr i$(bit+unit) %v1, $(bit)
	%c1 = trunc i$(bit+unit) %c to i$(unit)
	%r1 = insertvalue { i$(bit), i$(unit) } undef, i$(bit) %v, 0
	%r2 = insertvalue { i$(bit), i$(unit) } %r1, i$(unit) %c1, 1
	ret { i$(bit), i$(unit) } %r2
}

define void @mcl_fp_sub$(bit)S(i$(bit)* %pz, i$(bit)* %px, i$(bit)* %py, i$(bit)* %pp) {
	%x = load i$(bit)* %px
	%y = load i$(bit)* %py
	%x1 = zext i$(bit) %x to i$(bit+unit)
	%y1 = zext i$(bit) %y to i$(bit+unit)
	%vc = sub i$(bit+unit) %x1, %y1
	%v = trunc i$(bit+unit) %vc to i$(bit)
	%c = lshr i$(bit+unit) %vc, $(bit+unit-1)
	%c1 = trunc i$(bit+unit) %c to i1
	%p = load i$(bit)* %pp
	%a = select i1 %c1, i$(bit) %p, i$(bit) 0
	%v1 = add i$(bit) %v, %a
	store i$(bit) %v1, i$(bit)* %pz
	ret void
}

@define bu = bit + unit
@define b2 = bit * 2
@define b2u = b2 + unit
define void @mcl_fpDbl_add$(bit)(i$(bit)* %pz, i$(b2)* %px, i$(b2)* %py, i$(bit)* %pp) {
entry:
	%x = load i$(b2)* %px
	%y = load i$(b2)* %py
	%x1 = zext i$(b2) %x to i$(b2u)
	%y1 = zext i$(b2) %y to i$(b2u)
	%t0 = add i$(b2u) %x1, %y1 ; x + y = [H:L]
	%t1 = trunc i$(b2u) %t0 to i$(bit) ; t1 = L
	store i$(bit) %t1, i$(bit)* %pz ; store L

	%t2 = lshr i$(b2u) %t0, $(bit)
	%H = trunc i$(b2u) %t2 to i$(bu)

	%p = load i$(bit)* %pp
	%p1 = zext i$(bit) %p to i$(bu)
	%Hp = sub i$(bu) %H, %p1 ; H - p
	%t3 = lshr i$(bu) %Hp, $(bit)
	%t4 = trunc i$(bu) %t3 to i1
	%t5 = select i1 %t4, i$(bu) %H, i$(bu) %Hp
	%t6 = trunc i$(bu) %t5 to i$(bit)
	%pz1 = getelementptr i$(bit)* %pz, i32 1
	store i$(bit) %t6, i$(bit)* %pz1
	ret void
}

define void @mcl_fpDbl_sub$(bit)(i$(bit)* %pz, i$(b2)* %px, i$(b2)* %py, i$(bit)* %pp) {
	%x = load i$(b2)* %px
	%y = load i$(b2)* %py
	%x1 = zext i$(b2) %x to i$(b2u)
	%y1 = zext i$(b2) %y to i$(b2u)
	%vc = sub i$(b2u) %x1, %y1 ; x - y = [H:L]
	%L = trunc i$(b2u) %vc to i$(bit) ; L
	store i$(bit) %L, i$(bit)* %pz
	%vc1 = lshr i$(b2u) %vc, $(bit)
	%H = trunc i$(b2u) %vc1 to i$(bit) ; H
	%c = lshr i$(b2u) %vc, $(b2u-1)
	%c1 = trunc i$(b2u) %c to i1
	%p = load i$(bit)* %pp
	%a = select i1 %c1, i$(bit) %p, i$(bit) 0
	%v1 = add i$(bit) %H, %a
	%pz1 = getelementptr i$(bit)* %pz, i32 1
	store i$(bit) %v1, i$(bit)* %pz1
	ret void
}
