
define i$(unit*2) @mul$(unit)x$(unit)(i$(unit) %x, i$(unit) %y) {
	%x0 = zext i$(unit) %x to i$(unit*2)
	%y0 = zext i$(unit) %y to i$(unit*2)
	%z = mul i$(unit*2) %x0, %y0
	ret i$(unit*2) %z
}

@define u2 = unit * 2
define private i$(unit) @extractHigh$(unit)(i$(u2) %x)
{
	%t0 = lshr i$(unit*2) %x, $(unit)
	%t1 = trunc i$(unit*2) %t0 to i$(unit)
	ret i$(unit) %t1
}
define private void @storePos$(unit)(i$(unit) *%p, i$(unit) %v, i$(unit) %i)
{
	%pp = getelementptr i$(unit) *%p, i$(unit) %i
	store i$(unit) %v, i$(unit)* %pp
	ret void
}
define i$(u2) @mulPos$(unit)x$(unit)(i$(unit) *%px, i$(unit) %y, i$(unit) %i)
{
	%p = getelementptr i$(unit)* %px, i$(unit) %i
	%x = load i$(unit)* %p
	%xy = call i$(u2) @mul$(unit)x$(unit)(i$(unit) %x, i$(unit) %y)
	ret i$(u2) %xy
}

; NIST_P192
; 0xfffffffffffffffffffffffffffffffeffffffffffffffff
;
;       0                1                2
; ffffffffffffffff fffffffffffffffe ffffffffffffffff
;
; p = (1 << 192) - (1 << 64) - 1
; (1 << 192) % p = (1 << 64) + 1
;
; L : 192bit
; Hi: 64bit
; x = [H:L] = [H2:H1:H0:L]
; mod p
;    x = L + H + (H << 64)
;      = L + H + [H1:H0:0] + H2 + (H2 << 64)
;[e:t] = L + H + [H1:H0:H2] + [H2:0] ; 2bit(e) over
;    y = t + e + (e << 64)
;    if (y >= p) y -= p

define internal i64 @extract192to64(i192 %x, i192 %shift) {
	%t0 = lshr i192 %x, %shift
	%t1 = trunc i192 %t0 to i64
	ret i64 %t1
}

define internal i192 @makeNIST_P192() {
	%p0 = sub i64 0, 1
	%p1 = sub i64 0, 2
	%p2 = sub i64 0, 1
	%p0e = zext i64 %p0 to i192
	%p1e = zext i64 %p1 to i192
	%p2e = zext i64 %p2 to i192
	%p1s = shl i192 %p1e, 64
	%p2s = shl i192 %p2e, 128

	%t0 = add i192 %p0e, %p1s
	%p = add i192 %t0, %p2s
	ret i192 %p
}

define void @mcl_fpDbl_mod_NIST_P192(i192* %out, i192* %px) {
	%L192 = load i192* %px
	%L = zext i192 %L192 to i256

	%pH = getelementptr i192* %px, i32 1
	%H192 = load i192* %pH
	%H = zext i192 %H192 to i256

	%H10_ = shl i192 %H192, 64
	%H10 = zext i192 %H10_ to i256

	%H2_ = call i64 @extract192to64(i192 %H192, i192 128)
	%H2 = zext i64 %H2_ to i256
	%H102 = or i256 %H10, %H2

	%H2s = shl i256 %H2, 64

	%t0 = add i256 %L, %H
	%t1 = add i256 %t0, %H102
	%t2 = add i256 %t1, %H2s

	%e = lshr i256 %t2, 192
	%e1 = trunc i256 %e to i64
	%e2 = zext i64 %e1 to i256
	%e3 = shl i256 %e2, 64
	%e4 = or i256 %e2, %e3

	%t3 = trunc i256 %t2 to i192
	%t4 = zext i192 %t3 to i256

	%z = add i256 %t4, %e4

	%p = call i192 @makeNIST_P192()
	%pe = zext i192 %p to i256

	%c0 = sub i256 %z, %pe
	%c1 = lshr i256 %c0, 192
	%c2 = trunc i256 %c1 to i1
	%c3 = select i1 %c2, i256 %z, i256 %c0
	%c4 = trunc i256 %c3 to i192
	store i192 %c4, i192* %out
	ret void
}

define void @mcl_fp_sqr_NIST_P192(i192* %py, i$(unit)* %px) {
	%buf = alloca i192, i32 2
	%p = bitcast i192* %buf to i$(unit)*
	call void @mcl_fpDbl_sqrPre192(i$(unit)* %p, i$(unit)* %px)
	call void @mcl_fpDbl_mod_NIST_P192(i192* %py, i192* %buf)
	ret void
}
define void @mcl_fp_mul_NIST_P192(i192* %pz, i$(unit)* %px, i$(unit)* %py) {
	%buf = alloca i192, i32 2
	%p = bitcast i192* %buf to i$(unit)*
	call void @mcl_fpDbl_mulPre192(i$(unit)* %p, i$(unit)* %px, i$(unit)* %py)
	call void @mcl_fpDbl_mod_NIST_P192(i192* %pz, i192* %buf)
	ret void
}

; NIST_P521
; p = (1 << 521) - 1
; x = [H:L]
; x % p = (L + H) % p
@define len = 521
@define n = len / unit
@define round = unit * (n + 1)
@define round2 = unit * (n * 2 + 1)
@define rem = len - n * unit
@define mask = ((1 << unit) - (1 << rem))
define void @mcl_fpDbl_mod_NIST_P521(i$(round)* %py, i$(round2)* %px) {
	%x = load i$(round2)* %px
	%L0 = trunc i$(round2) %x to i$(len)
	%L = zext i$(len) %L0 to i$(round)
	%H0 = lshr i$(round2) %x, $(len)
	%H = trunc i$(round2) %H0 to i$(round) ; x = [H:L]
	%t = add i$(round) %L, %H ; t = L + H
	%t0 = lshr i$(round) %t, $(len)
	%t1 = and i$(round) %t0, 1
	%t2 = add i$(round) %t, %t1
	%t3 = trunc i$(round) %t2 to i$(len)
	%z0 = zext i$(len) %t3 to i$(round)
	%z1 = call i$(unit) @extract$(round)(i$(round) %z0, i$(round) $(n * unit))
	%m0 = or i$(unit) %z1, $(mask)
@for i, 0, n
	%s$(i) = call i$(unit) @extract$(round)(i$(round) %z0, i$(round) $(unit*i))
	%m$(i+1) = and i$(unit) %m$(i), %s$(i)
@endfor
	%c = icmp eq i$(unit) %m$(n), -1
	br i1 %c, label %zero, label %nonzero
zero:
	store i$(round) 0, i$(round)* %py
	ret void
nonzero:
	store i$(round) %z0, i$(round)* %py
	ret void
}
