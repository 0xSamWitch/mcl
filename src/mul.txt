@define bu = bit + unit
@define u2 = unit*2
define i$(bu) @mulPv$(bit)x$(unit)(i$(unit)* %px, i$(unit) %y)
{
@for i, 0, N
	%x$(i)y = call i$(u2) @mulPos$(unit)x$(unit)(i$(unit) *%px, i$(unit) %y, i$(unit) $(i))
	%L$(i) = trunc i$(u2) %x$(i)y to i$(unit)
	%H$(i) = call i$(unit) @extractHigh$(unit)(i$(u2) %x$(i)y)
@endfor

@for i, 1, N
	%L$(i)e = zext i$(unit) %L$(i) to i$(bit)
@if i > 1
	%L$(i)es = shl i$(bit) %L$(i)e, $(unit * i - unit)
@endif
@endfor
@if N > 2
	%Lt1 = or i$(bit) %L1e, %L2es
@endif
@for i, 1, N - 2
	%Lt$(i+1) = or i$(bit) %Lt$(i), %L$(i+2)es
@endfor

	%H0e = zext i$(unit) %H0 to i$(bit)
@for i, 1, N
	%H$(i)e = zext i$(unit) %H$(i) to i$(bit)
	%H$(i)es = shl i$(bit) %H$(i)e, $(unit * i)
@endfor
	%Ht1 = or i$(bit) %H0e, %H1es
@for i, 2, N
	%Ht$(i) = or i$(bit) %Ht$(i-1), %H$(i)es
@endfor
@if N == 2
	%t = add i$(bit) %Ht$(N-1), %L1e
@else
	%t = add i$(bit) %Ht$(N-1), %Lt$(N-2)
@endif

	%t1 = zext i$(bit) %t to i$(bu)
	%t2 = shl i$(bu) %t1, $(unit)
	%t3 = zext i$(unit) %L0 to i$(bu)
	%t4 = or i$(bu) %t2, %t3
	ret i$(bu) %t4
}

@define u2 = unit*2
define void @mcl_fp_mul_UnitPre$(bit)(i$(bu) *%pz, i$(unit) *%px, i$(unit) %y)
{
  %z = call i$(bu) @mulPv$(bit)x$(unit)(i$(unit)* %px, i$(unit) %y)
  store i$(bu) %z, i$(bu) *%pz
  ret void
}

define void @mcl_fpDbl_mulPre$(bit)(i$(unit)* %pz, i$(unit)* %px, i$(unit)* %py) {
  %y0 = load i$(unit)* %py
  %xy0 = call i$(bu) @mulPv$(bit)x$(unit)(i$(unit) *%px, i$(unit) %y0)
  %z0 = trunc i$(bu) %xy0 to i$(unit)
  store i$(unit) %z0, i$(unit)* %pz
  %t0 = lshr i$(bu) %xy0, $(unit)

@for i, 1, N
  %py$(i) = getelementptr i$(unit)* %py, i32 $(i)
  %y$(i) = load i$(unit)* %py$(i)
  %xy$(i) = call i$(bu) @mulPv$(bit)x$(unit)(i$(unit)* %px, i$(unit) %y$(i))
  %a$(i) = add i$(bu) %t$(i-1), %xy$(i)
  %z$(i) = trunc i$(bu) %a$(i) to i$(unit)
  %pz$(i) = getelementptr i$(unit)* %pz, i32 $(i)
  @if i < N - 1
    store i$(unit) %z$(i), i$(unit)* %pz$(i)
    %t$(i) = lshr i$(bu) %a$(i), $(unit)
  @endif
@endfor

  %pz$(N-1)e = bitcast i$(unit)* %pz$(N-1) to i$(bu)*
  store i$(bu) %a$(N-1), i$(bu)* %pz$(N-1)e

  ret void
}

define void @mcl_fpDbl_sqrPre$(bit)(i$(unit)* %py, i$(unit)* %px) {
  %x0 = load i$(unit)* %px
  %xx0 = call i$(bu) @mulPv$(bit)x$(unit)(i$(unit) *%px, i$(unit) %x0)
  %s0 = trunc i$(bu) %xx0 to i$(unit)
  store i$(unit) %s0, i$(unit)* %py
  %t0 = lshr i$(bu) %xx0, $(unit)

@for i, 1, N
  %px$(i) = getelementptr i$(unit)* %px, i32 $(i)
  %x$(i) = load i$(unit)* %px$(i)
  %xx$(i) = call i$(bu) @mulPv$(bit)x$(unit)(i$(unit)* %px, i$(unit) %x$(i))
  %a$(i) = add i$(bu) %t$(i-1), %xx$(i)
  %s$(i) = trunc i$(bu) %a$(i) to i$(unit)
  %py$(i) = getelementptr i$(unit)* %py, i32 $(i)
  @if i < N - 1
    store i$(unit) %s$(i), i$(unit)* %py$(i)
    %t$(i) = lshr i$(bu) %a$(i), $(unit)
  @endif
@endfor

  %py$(N-1)e = bitcast i$(unit)* %py$(N-1) to i$(bu)*
  store i$(bu) %a$(N-1), i$(bu)* %py$(N-1)e

  ret void
}

@define bu = bit + unit
@define bu2 = bit + unit * 2
define void @mcl_fp_mont$(bit)(i$(bit)* %pz, i$(unit)* %px, i$(unit)* %py, i$(unit)* %pp, i$(unit) %r) {
	%ppt = bitcast i$(unit)* %pp to i$(bit)*
	%p = load i$(bit)* %ppt

@for i, 0, N
	%py$(i) = getelementptr i$(unit)* %py, i$(unit) $(i)
	%y$(i) = load i$(unit)* %py$(i)
	%xy$(i) = call i$(bu) @mulPv$(bit)x$(unit)(i$(unit)* %px, i$(unit) %y$(i))
@if i == 0
	%a0 = zext i$(bu) %xy0 to i$(bu2)

	%at$(i) = trunc i$(bu) %xy$(i) to i$(unit)
@else
	%xye$(i) = zext i$(bu) %xy$(i) to i$(bu2)
	%a$(i) = add i$(bu2) %s$(i-1), %xye$(i)
	%at$(i) = trunc i$(bu2) %a$(i) to i$(unit)
@endif
	%q$(i) = mul i$(unit) %at$(i), %r
	%pq$(i) = call i$(bu) @mulPv$(bit)x$(unit)(i$(unit)* %pp, i$(unit) %q$(i))
	%pqe$(i) = zext i$(bu) %pq$(i) to i$(bu2)
	%t$(i) = add i$(bu2) %a$(i), %pqe$(i)
	%s$(i) = lshr i$(bu2) %t$(i), $(unit)
@endfor
	%v = trunc i$(bu2) %s$(N-1) to i$(bu)
	%pe = zext i$(bit) %p to i$(bu)
	%vc = sub i$(bu) %v, %pe
	%c = lshr i$(bu) %vc, $(bit)
	%c1 = trunc i$(bu) %c to i1
	%z = select i1 %c1, i$(bu) %v, i$(bu) %vc
	%zt = trunc i$(bu) %z to i$(bit)
	store i$(bit) %zt, i$(bit)* %pz
	ret void
}

@define b2 = bit * 2
@define b2u = b2 + unit
define void @mcl_fp_montRed$(bit)(i$(bit)* %pz, i$(b2)* %pxy, i$(unit)* %pp, i$(unit) %r) {
	%ppt = bitcast i$(unit)* %pp to i$(bit)*
	%p = load i$(bit)* %ppt
	%xy = load i$(b2)* %pxy
	%t0 = zext i$(b2) %xy to i$(b2+unit)

@for i, 0, N
	%z0$(i+1) = trunc i$(b2u - unit * i) %t$(i) to i$(unit)
	%q$(i) = mul i$(unit) %z0$(i+1), %r
	%pq$(i) = call i$(bu) @mulPv$(bit)x$(unit)(i$(unit)* %pp, i$(unit) %q$(i))
	%pqe$(i) = zext i$(bu) %pq$(i) to i$(b2u - unit * i)
	%z$(i+1) = add i$(b2u - unit * i) %t$(i), %pqe$(i)
	%zt$(i+1) = lshr i$(b2u - unit * i) %z$(i+1), $(unit)
	%t$(i+1) = trunc i$(b2u - unit * i) %zt$(i+1) to i$(b2 - unit * i)
@endfor
	%pe = zext i$(bit) %p to i$(bu)
	%vc = sub i$(bu) %t$(N), %pe
	%c = lshr i$(bu) %vc, $(bit)
	%c1 = trunc i$(bu) %c to i1
	%z = select i1 %c1, i$(bu) %t$(N), i$(bu) %vc
	%zt = trunc i$(bu) %z to i$(bit)
	store i$(bit) %zt, i$(bit)* %pz
	ret void
}

